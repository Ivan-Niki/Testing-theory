========= Что такое функциональное тестирование (Functional/Behavioral testing)? ===========

Функциональное тестирование представляет собой проверки ПО, по результатам которых устанавливается соответствие этого ПО исходным требованиям заказчика. 
Иными словами, с помощью проведения данных тестов устанавливается способность ПО в конкретных условиях решать пользовательские задачи.
Функциональные тесты основываются на функциях, выполняемых системой, и могут проводиться на всех уровнях 
тестирования (компонентном, интеграционном, системном, приемочном). 
Как правило, эти функции описываются в требованиях, функциональных спецификациях или в виде случаев использования системы (use cases).


========= Что такое нефункциональное тестирование (Non-Functional testing)? ===========

В отличии от функционального тестирования, целью которого является проверка соответствия реальных функций продукта с функциональными требованиями; 
целью нефункционального тестирования является проверка соответствия свойств приложения с его нефункциональными требованиями.
Нефункциональное тестирование – тестирование свойств, которые не относятся к функциональности системы. 

Данные свойства определяются нефункциональными требованиями, которые характеризуют продукт с таких сторон, как:
- Надежность (реакция системы на непредвиденные ситуации).
- Производительность (Работоспособность системы под разными нагрузками).
- Удобство (Исследование удобности работы с приложением с точки зрения пользователя).
- Масштабируемость (Требования к горизонтальному или вертикальному масштабированию приложения).
- Безопасность (Защищенность пользовательских данных).
- Портируемость (Переносимость приложения на различные платформы).

Данные свойства системы можно исследовать, используя следующие виды тестирования:
-> Тестирование установки (Installation testing) – проверка успешности установки приложения, его настройки и 
удаления. Снижает риски потери пользовательских данных, потери работоспособности приложения и пр.
-> Тестирование удобства использования (Usability testing) – характеризует систему с точки зрения удобства 
использования конечного пользователя.
-> Конфигурационное тестирование (или тестирование портируемости) – исследование работоспособности программной 
системы в условиях различных программных конфигураций.
-> Тестирование на отказ и восстановление (Failover and Recovery Testing) – исследование программной системы на 
предмет восстановления после ошибок, сбоев. Оценивание реакции защитных свойств приложения.


========= Какие виды тестирования относятся к функциональному тестированию? ===========


========= Какие виды тестирования относятся к нефункциональному тестированию? ===========
1) Тестирование графического интерфейса (GUI testing) — анализ соответствия графического пользовательского 
интерфейса программы спецификациям, макетам, прототипам, стандартам.

2) Тестирование удобства использования (Usability testing) — исследование, выполняемое с целью определения, удобна ли программа для ее предполагаемого применения и основанное на стандартах, лучших практиках и привлечении 
пользователей в качестве тестировщиков и суммировании и анализе полученных от них выводов.

3) Тестирование инсталляции (Installation testing) — тестирование, направленное на проверку процессов установки, 
удаления, восстановления, обновления, лицензирования.

4) Тестирование безопасности (Safety testing) — тестирование программного продукта с целью с целью определить его безопасность.
Безопасность (Safety) — способность программного продукта при использовании оговоренным образом оставаться в 
рамках приемлемого риска причинения вреда здоровью, бизнесу, программам, собственности или окружающей среде.

5) Тестирование защищенности (Security testing) — тестирование с целью оценить защищенность программного продукта.
Защищенность (Security) — Свойства программного продукта, отражающие его способность не допускать 
неавторизированный доступ, случайный или умышленный, к программам и данным.

6) Тестирование доступности (Accessibility testing) — тестирование, направленное на определение степени 
легкости, с которой пользователи с ограниченными способностями могут использовать систему или ее компоненты.

7) Тестирование производительности (Performance testing) — процесс тестирования с целью определить 
производительность программного продукта.

8) Нагрузочное тестирование (Load testing) — вид тестирования производительности, проводимый с целью оценить 
поведение компонента или системы под увеличивающейся нагрузкой (число одновременно работающих пользователей 
и/или число транзакций) для определения максимально допустимого уровня нагрузки для исследуемого компонента или системы.

9) Стрессовое тестирование (Stress testing) — Вид тестирования производительности, оценивающий систему или 
компонент на граничных значениях рабочих нагрузок или за их пределами, или же в состоянии ограниченных ресурсов, 
таких как память или доступ к серверу.

10) Тестирование интернационализации (Internationalization testing) — Анализ приложения и его интерфейса на 
способность быть переведённым.

11) Тестирование локализации (Localization testing) — Анализ приложения и его сопроводительной документации на 
корректность в конкретной переведённой среде.

12) Тестирование совместимости (Compatibility testing):

13) Тестирование кроссбраузерности (Cross browser testing) — Вид тестирования совместимости, направленный на 
анализ работы приложения в разных браузерах либо разных версиях одного браузера.

14) Тестирование кроссплатформенности (Cross platform testing) — Анализ работы одного и того же приложения на 
разных операционных системах\платформах.


========= Что такое Статическое/Динамическое тестированию? ===========
1) Статическое тестирование — не требует выполнения кода; это его суть. При этом оно может быть ручным или 
автоматизированным (например автоматические чекеры синтаксиса). 
Статические тесты начинаются на ранних этапах цикла разработки (SDLC). Такие тесты незаменимы при проверке MVP. 
Иногда даже не нужен компьютер — просто вручную проверяются самые базовые функции.
Техники статического тестирования включают, например, “тестирование” базовой документации приложения; 
поверхностную проверку кода; также документации по дизайну; спецификации функций; и требований по основным функциям.

2) Динамическое тестирование подразумевает выполнение кода при тестировании. 
Проверяется поведение приложения и функции, оценивается как задействованы память и процессор, и в целом производительность. 
QA-команда убеждается, что софт работает в соответствии с use-кейсами, ориентированными на бизнес-цели.
Динамическое тестирование имеет дело уже с полностью функциональным продуктом. QA-инженеры находят проблемы в 
логике и узкие места в инфраструктуре приложения, которые не были заметны на этапе написания проектной документации.
Динамическое тестирование проверяет, как работает код при выполнении — и сверяет результаты с ожидаемыми. 
Такое тестирование могут проводить на любом этапе жизненного цикла, и оно может быть как по типу черного ящика, так и белого ящика.
Динамическое тестирование находит сложные дефекты, невидимые при поверхностном анализе кода, во время статического тестирования.


========== Что такое Черный/Серый/Белый ящик тестирования(White/Black/Grey Box testing)? ==========
В методологии QA (Quality Assurance) есть классификация методов тестирования по прозрачности системы (программы, приложения). 
Она определяется тем, может ли тестировщик видеть код программного обеспечения и работать с ним.
Вот самое простое определение: 
- Тестирование белого ящика базируется на знаниях об устройстве системы. 
- Тестирование черного ящика базируется на знаниях требований к системе.

----- Метод "черного ящика" (Black box testing) -----
Тестирование методом Черного Ящика — это стратегия или метод тестирования, которая базируется только на 
тестировании по функциональной спецификации и требованиям, при этом не смотря во внутреннюю структуру кода 
и без доступа к базе данных.
Фактически мы знаем какой должен быть результат при определенном наборе данных, которые подаются на вход.
Нам достаточно знать, что должно быть при таком-то поведении пользователя и при таких-то наборах данных (зависит от специфики проекта).
Результат проверяем с юзер-интерфейса на уровне простого пользователя. 
На данный момент такая стратегия является наиболее часто применимой в IT компаниях.
Тестирование черного ящика — это, в первую очередь, проверка того, что продукт соответствует функциональным требованиям. 
Такое тестирование проводится на основе документации.

----- Метод "белого ящика" (White box testing) -----
Тестирование методом "белого ящика" ("стеклянного ящика") проверяет исходный код и ставит целью убедиться, что он работает правильно. 
Инженер, занимающийся тестированием методом "белого ящика", должен знать программирование на достаточном уровне. 
Часто такое тестирование проводят сами разработчики.

Два основных метода проведения тестирования методом "белого ящика":
--> 1) Statement coverage testing — покрытие операторов. Во время тестирования покрывают код так, чтобы каждый 
оператор выполнился хотя бы один раз.
--> 2) Decision/Branch coverage testing — покрытие решений. Код покрывается тестами так, чтобы во время 
тестирования выполнились все ветки всех условных операторов.

Наименьшая часть тестировщиков способны анализироваь чужой код и заниматься написанием тестов, не запуская 
программу или приложение, а только базируясь на коде.
Таких специалистов на рынке очень мало, и они скорее всего бывшие разработчики, ушедшие в тестирование или 
увлекающиеся программированием.

------ Метод "серого ящика" (Grey box testing) -----

Чуть меньшее количество тестировщиков тестируют стратегией "серого ящика", которая подразумевает частичный 
доступ, например к структуре баз данных или наборов параметров, которые принимают сервисы.
Тестировщик не влезает в код глубоко, но может посмотреть его реализацию, например, через инструмент разработчика (DevTools).
Тестирование методом «серого ящика» — это форма тестирования, сочетающая тестирование методом «белого ящика» и тестирование методом «черного ящика», использующая частичное понимание базового дизайна и способа реализации системы.
Такое сочетание означает, что тестировщик знает часть того, что происходит в фоновом режиме без полного знания 
кода, что позволяет лучше понять потенциальные причины проблем в программном обеспечении, когда они возникают.
Проведение тестирования методом «серого ящика» входит в обязанности тестировщиков, при этом команда обеспечения 
качества работает над проектом независимо от команды разработчиков.

--- Пример работы по методу "серого ящика" ----

1. Предоставлена информация о базе данных. Если программа использует для своей работы какую-либо БД, мы можем проанализировать типы полей, в которые записываются переменные программы. 
А потом проанализировать ограничения, которые накладывает база.

Например, если вводимая фамилия пользователя записывается в поле типа «строка» длиной 128 символов, мы должны:

- Попробовать найти фамилию длиннее, чем 128 символов. Если такие фамилии существуют, то человек с такой 
фамилией не сможет воспользоваться нашей системой — это довольно серьезный баг;
- Независимо от того, существуют или нет такие фамилии, попробовать ввести строку больше 128 символов. 
Программа не должна ломаться (должна выдавать внятное сообщение об ошибке).

2. Если программа интегрируется с другими внешними системами, помимо базы данных, можно также проанализировать ограничения таких систем. 
Например, если мы тестируем почтовый IMAP-клиент, следует убедиться, что он корректно обрабатывает длинные пути к папкам на сервере (чаще всего, ограничение на длину пути составляет 255 символов).

3. Пример тестирования методом "серого ящика": 
При тестировании таких элементов веб-сайта, как ссылки или "битые" ссылки, если тестировщик обнаружит какие-либо 
проблемы с этими ссылками, то он может сразу же внести изменения в HTML-код и проверить их в режиме реального времени.



=============== УРОВНИ ТЕСТИРОВАНИЯ (Testing Levels) ==============

Acceptance Testing
      ↑
System Testing
      ↑
Integration Testing
      ↑
Module/Unit/Component testing

---------- Что такое Компонентное (Component or Unit Testing) тестирование -----------

Компонент (component) - наименьший элемент программного обеспечения, который может быть протестирован отдельно.
Компонентное тестирование (component testing) - тестирование отдельных компонентов программного обеспечения.

Компонентное тестирование - тип тестирования ПО, при котором тестирование выполняется для каждого отдельного 
компонента отдельно, без интеграции с другими компонентами. Его также называют модульным тестированием (Module 
testing), если рассматривать его с точки зрения архитектуры. Как правило, любое программное обеспечение в целом 
состоит из нескольких компонентов. Тестирование на уровне компонентов (Component Level testing) имеет дело с 
тестированием этих компонентов индивидуально. Это один из самых частых типов тестирования черного ящика, который 
проводится командой QA.

Модульное тестирование (оно же юнит-тестирование) используется для тестирования какого-либо одного логически 
выделенного и изолированного элемента системы (отдельные методы класса или простая функция, subprograms, 
subroutines, классы или процедуры) в коде. 
Очевидно, что это тестирование методом БЕЛОГО ящика и чаще всего оно проводится самими разработчиками.
На уровне модульного тестирования проще всего обнаружить дефекты, связанные с алгоритмическими ошибками и 
ошибками кодирования алгоритмов, типа работы с условиями и счетчиками циклов, а также с использованием локальных 
переменных и ресурсов.


---------- Интеграционное тестирование (Integration testing) -----------

Интеграционное тестирование предназначено для проверки насколько хорошо два или более компонента ПО 
взаимодействуют друг с другом, а также взаимодействия с различными частями системы (операционной системой, 
оборудованием либо связи между различными системами).
Смысл интеграционного тестирования заключается в процессе тестирования интерфейсов между двумя компонентами или 
программными модулями для оценки того, как данные передаются между ними.
Интеграционное тестирование обычно проводится после модульного тестирования, которое включает в себя 
тестирование отдельных модулей и блоков. 
После того, как установлено, что каждый блок работает изолированно, интеграционное тестирование оценивает, как 
эти блоки работают при объединении.

Зачем нужно интеграционное тестирование:
— Разные разработчики используют разную логику при разработке модулей даже для одного и того же программного 
приложения. Интеграционное тестирование — это единственный способ убедиться, что отдельные модули работают 
вместе так, как должны.
— Когда данные переходят от одного модуля к другому, структура этих данных может измениться, а некоторые 
значения могут быть удалены. Это может вызвать значительные проблемы в работе модулей.
— Модули взаимодействуют со сторонними инструментами и API. Важно протестировать интеграцию, чтобы убедиться, 
что данные, принимаемые API или сторонним инструментом, корректны, а генерируемые ответы также соответствуют ожиданиям.
— Если разработчик внедряет изменения без модульного тестирования, интеграционное тестирование необходимо для 
оценки эффективности изменений.

Уровни интеграционного тестирования:
- Компонентный интеграционный уровень (Component Integration testing)
Проверяется взаимодействие между компонентами системы после проведения компонентного тестирования.
- Системный интеграционный уровень (System Integration Testing)
Проверяется взаимодействие между разными системами после проведения системного тестирования.

Подходы к интеграционному тестированию:
1) Подход большой взрыв ("Big Bang" Integration).
Все или практически все разработанные модули собираются вместе в виде законченной системы или ее основной части, 
и затем проводится интеграционное тестирование. Такой подход очень хорош для сохранения времени. Однако если 
тест кейсы и их результаты записаны не верно, то сам процесс интеграции сильно осложнится, что станет преградой 
для команды тестирования при достижении основной цели интеграционного тестирования.

2) Инкрементальный подход (Incremental Approach).
При таком подходе тестирование выполняется путем объединения двух или более логически связанных модулей. 
Затем другие связанные модули поэтапно добавляются и тестируются для правильного функционирования. 
Процесс продолжается до тех пор, пока все модули не будут соединены и успешно протестированы. 

Осуществляется разными методами:
-> Сверху вниз (нисходящий подход) (Top-Down Integration)
Вначале тестируются все высокоуровневые модули, и постепенно один за другим добавляются низкоуровневые. 
Все модули более низкого уровня симулируются заглушками с аналогичной функциональностью, затем по мере 
готовности они заменяются реальными активными компонентами. Таким образом мы проводим тестирование сверху вниз.
-> Снизу вверх (восходящий подход) (Bottom-Up Integration)
Все низкоуровневые модули, процедуры или функции собираются воедино и затем тестируются. После чего собирается 
следующий уровень модулей для проведения интеграционного тестирования. 
Данный подход считается полезным, если все или практически все модули, разрабатываемого уровня, готовы. 
Также данный подход помогает определить по результатам тестирования уровень готовности приложения.
-> Гибридный/сэндвич-подход (Sandwich/Hybrid Approach)
Представляет собой комбинацию восходящего и нисходящего подходов. Здесь целью является средний слой, в то время 
как драйверы заменяют верхний слой, а заглушки нижний пока компоненты этих слоев не будут разработаны.


============ Системное тестирование (System Testing) ============

Системное тестирование означает тестирование всей системы в целом, оно выполняется после интеграционного 
тестирования, чтобы проверить, работает ли вся система целиком должным образом. 
В основном это тестирование типа «черный ящик», которое оценивает работу системы с точки зрения пользователя с 
помощью документа спецификации и оно не требует каких-либо внутренних знаний о системе, таких как дизайн или структура кода.
Основной задачей системного тестирования является проверка как функциональных, так и не функциональных требований в системе в целом.
Для минимизации рисков, связанных с особенностями поведения системы в той или иной среде, во время тестирования 
рекомендуется использовать окружение максимально приближенное к тому, на которое будет установлен продукт после выдачи.

Можно выделить два подхода к системному тестированию:
--> на базе требований (requirements based)
Для каждого требования пишутся тестовые случаи (test cases), проверяющие выполнение данного требования.
--> на базе случаев использования (use case based)
На основе представления о способах использования продукта создаются случаи использования системы (Use Cases). 
По конкретному случаю использования можно определить один или более сценариев. 
На проверку каждого сценария пишутся тест кейсы (test cases), которые должны быть протестированы.

=========== ПРИЕМОЧНОЕ ТЕСТИРОВАНИЕ (Acceptance testing - AT) ===========

Приемочное тестирование – это комплексное тестирование, необходимое для определения уровня готовности системы к последующей эксплуатации.
Тестирование проводится на основании набора тестовых сценариев, покрывающих основные бизнес-операции системы.

Приемочное тестирование (Acceptance Testing) - формальный процесс тестирования, который проверяет соответствие 
системы требованиям и проводится с целью:
- определения удовлетворяет ли система приемочным критериям;
- вынесения решения заказчиком или другим уполномоченным лицом принимается приложение или нет.

Приемочное тестирование выполняется на основании набора типичных тестовых случаев и сценариев, разработанных на 
основании требований к данному приложению.
Решение о проведении приемочного тестирования принимается, когда:
- продукт достиг необходимого уровня качества;
- заказчик ознакомлен с Планом Приемочных Работ (Product Acceptance Plan) или иным документом, где описан набор 
действий, связанных с проведением приемочного тестирования, дата проведения, ответственные и т.д.

----- Виды приемочного тестирования: -----

1) Пользовательское приемочное тестирование (UAT - User Acceptance Testing, validation, end-user testing) 
выполняется пользователем или клиентом чтобы определить, может ли ПО быть принято (accepted) или нет и проверить 
ПО на соответствие бизнес-требованиям.
2) Бизнес - приемочное тестирование (BAT - Business Acceptance Testing) необходимо для оценки того, 
соответствует ли Продукт бизнес-целям и задачам.
3) Правовое приемочное тестирование (RAT - Regulations/Compliance Acceptance Testing) необходимо для оценки 
того, нарушает ли Продукт правила и нормы, установленные правительством страны, в которой он выпускается.
4) Операционное (эксплуатационное) тестирование (OAT - Operational Acceptance testing) проводится с целью 
убедиться, что система выполняет свою роль в среде эксплуатации согласно бизнес-модели. 
Проверка так называемой «операционной готовности» продукта, включающая как правило нефункциональное 
тестирование, его многочисленные специальные виды, как-то тестирование совместимости, восстановления, масштабируемости, надежности и т.п.
Иными словами, тестируют то, что задействует саму операционную систему и программное обеспечение, — планы 
резервного копирования, процессы обслуживания ПО и проверку безопасности.
Данный вид тестирования проводится до пользовательского приемочного тестирования.
Целью эксплуатационного тестирования является обеспечение бесперебойной работы системы в ее стандартной 
эксплуатационной среде (SOE - standard operating environment).
5) Альфа-тестирование (Alpha Testing) проводят для оценки продукта в среде разработки / тестирования 
специализированной командой тестировщиков, обычно называемой альфа-тестерами. Альфа-тестирование часто 
используется как форма внутреннего приемочного тестирования перед проведением бета-тестирования.
6) Бета-тестирование, полевые испытания (Beta Testing, Field Testing) проводят для оценки Продукта, предоставляя его реальным конечным пользователям, обычно называемым бета-тестерами / бета-пользователями, в их среде.
Бета-тестирование проводится после альфа-тестирования и может использоваться как приемочное тестирование 
внешними пользователями. Бета-версия системы передается группе пользователей вне команды разработки, чтобы 
снизить количество дефектов. Иногда версия передается нескольким командам, чтобы получить обратную связь от как 
можно большего количества будущих пользователей.


============ ПОЗИТИВНОЕ / НЕГАТИВНОЕ ТЕСТИРОВАНИЕ ============

Позитивное тестирование – это тестирование с применением сценариев, которые соответствуют нормальному (штатному, 
ожидаемому) поведению системы. С его помощью мы можем определить, что система делает то, для чего и была создана.

Примеры:
- умножить на калькуляторе цифр 3 и 5,
- в игре посадить морковь на грядку для овощей,
- оплатить покупку действующей картой.

Негативным называют тестирование, в рамках которого применяются сценарии, которые соответствуют внештатному 
поведению тестируемой системы. Это могут быть исключительные ситуации или неверные данные.
Примеры:
- умножить на калькуляторе числа 3 на грушу (значение «груша» не является валидным для калькулятора),
- в игре посадить морковь на реку,
- оплатить покупку несуществующей картой.

----- Реакция продукта на тесты -----
Какой результат мы ждем от позитивных и негативных тестов?

Позитивное тестирование должно нам всегда давать результат в виде отсутствия багов.

Негативные проверки могут дать 2 результата:
1. На данный ввод у продукта есть ответ в виде сообщения/контроля.
2. Система не знает, как реагировать на введенные данные.

Получается, есть три реакции на действия по вводу данных:
— Действие: создание сущности, переход на новый шаг и т.п.
— Контроль: сообщение с контролем, блокировка дальнейших действий и т.п.
— Отказ: возникает исключение Exception, 404-ой ошибки и т.п.


============ АЛЬФА-ТЕСТИРОВАНИЕ (Alpha Testing) ============

Альфа-тестирование — это начальный этап проверки ПО, когда команда тестировщиков оценивает программу на предмет 
наличия дефектов перед её релизом для конечных пользователей.
Альфа-тестирование имитирует действия конечных пользователей для проверки поведения ПО в реальных условиях.
Альфа-тестирование проводится внутренней группой тестировщиков или иногда заказчиком.


============ БЕТА-ТЕСТИРОВАНИЕ (Beta Testing) ============
Бета-тестирование предполагает релиз ПО для ограниченной группы пользователей с целью получения реальных отзывов 
и выявления потенциальных проблем перед полномасштабным релизом.
Такой вид тестирования часто выполняется до официального релиза ПО. В нём участвует небольшое число конечных 
пользователей (бета-тестеров), которые проверяют совместимость программы и предоставляют обратную связь 
касательно обнаруженных дефектов и удобства использования.

Бета-тестирование бывает открытым и закрытым.
При открытом бета-тестировании программное обеспечение становится доступным для широкой аудитории. 
Закрытое бета-тестирование ограничено конкретной группой пользователей, которую выбрала команда разработчиков.


============ ИНТУИТИВНОЕ ТЕСТИРОВАНИЕ ============

Интуитивное тестирование (ad-hoc testing) — вид тестирования, который выполняется без подготовки к тестам, без 
определения ожидаемых результатов, проектирования тестовых сценариев. Это неформальное, импровизационное тестирование. 
Он не требует никакой документации, планирования, процессов которых следует придерживаться в выполнении. Также 
на данный вид тестирования не пишутся тест-кейсы, что в свою очередь может вызвать определенные затруднения в 
попытках воспроизвести дефект в системе. Такой вид зачастую может дать сходу больше результата чем тестирование 
по заранее определенным сценариям. Это обусловлено тем, что тестировщик на первых шагах приступает к 
тестированию основного функционала и выполняет нестандартные проверки, точнее некоторые из его проверок будут 
нестандартными.

----- Когда выполняется интуитивное тестирование (ad-hoc testing) ? -----
Чаще всего такое тестирование выполняется когда мало времени на точное и последовательное тестирование. При этом 
тестировщик полагается на свое общее представление о приложении и здравый смысл

Тестирование ad-hoc имеет смысл только в случае если тестировщик владеет общей информацией о продукте. Если 
человек совсем не будет знать продукт, то потратит время на его изучение, особенно если проект очень сложный и 
большой. Поэтому нужно хорошее представление о целях проекта, его назначению и основным функциям и возможностям. 
А дальше уже можно приступать к ad-hoc testing.

----- Виды интуитивного тестирования: -----
-> 1) buddy testing (совместное тестирование) — когда 2 человека, как правило разработчик + тестировщик, работают 
параллельно и находят дефекты в одном и том же модуле. Такой вид тестирования помогает тестировщику выполнять 
необходимые проверки, а программисту фиксить баги на ранних этапах.
-> 2) pair testing (парное тестирование) — когда 2 тестировщика проверяют один модуль и помогают друг другу. К 
примеру один может искать дефекты, а второй их документировать. Таким образом у одного тестера будет функция, 
скажем так обнаружителя, у другого — описателя
   
Различия между buddy testing и pair testing:
Совместное тестирование — это сочетание юнит тестирования и системного тестирования между разработчиком и тестировщиком
Парное тестирование выполняется только тестировщиками с разным уровнем знаний и опыта (такое сочетание поможет 
поделиться взглядами и идеями)

-> 3) monkey testing — произвольное тестирование программы с целью ее сломать

Основные преимущества ad-hoc testing:
- нет необходимости тратить время для подготовки документации;
- самые важные дефекты обнаруживаются на ранних этапах;
- часто применяется когда берут нового сотрудника. Методом адхока человек схватывает за 3 дня то, что по тесткейсам разбирал бы неделю — это называется форсированное обучение новых сотрудников;
- возможность найти хитрые дефекты, которые нельзя было бы найти используются стандартные сценарии проверок.


=========== ИССЛЕДОВАТЕЛЬСКОЕ ТЕСТИРОВАНИЕ (EXPLORATORY TESTING) ===========

Ad-hoc тестирование.
Под ad-hoc тестированием обычно понимают тестирование без использования спецификаций, планов и разработанных тест-кейсов, просто чистая импровизация.

Исследовательское тестирование (далее ИТ).
По ISTQB и Джеймсу Баху исследовательское тестирование – это неформальный метод проектирования тестов, при 
котором тестировщик активно контролирует проектирование тестов в то время, когда эти тесты выполняются, и 
использует полученную во время тестирования информацию для проектирования новых и улучшенных тестов. 
Простыми словами, это более осознанная версия ad-hoc тестирования, не требующая написания тест-кейсов, но 
подразумевающая, что каждый последующий тест определяется на основании результата предыдущего теста. Есть еще 
одно короткое определение по Сэму Канеру, «Testing Computer Software», «исследовательское тестирование — 
вдумчивый подход к ad-hoc тестированию».

Исследовательское тестирование (Exploratory Testing) — это методика, которая позволяет тестировщикам применять 
свой опыт и интуицию для обнаружения дефектов в программном обеспечении без заранее определенных тест-кейсов.
Исследовательское тестирование — это подход (один из видов тестирования ПО) , который помогает выявить дефекты, 
которые могли бы остаться незамеченными при стандартном тестировании с заранее определенными сценариями. 

Основные причины для его применения включают:
-> Поиск неожиданных дефектов: тестирование позволяет обнаружить проблемы, которые не были задокументированы или не были предусмотрены в тест-кейсах.
-> Адаптивность: Тестировщики могут быстро реагировать на изменения в коде и требованиях, не ожидая обновления тест-кейсов.
-> Креативность: Этот метод позволяет тестировщикам использовать свое творчество и интуицию при поиске дефектов.



============ ДЫМОВОЕ ТЕСТИРОВАНИЕ (Smoke testing) ============
Smoke-тестирование — проверка программного обеспечения на стабильность и наличие явных ошибок. 
Тест должен подтвердить или опровергнуть правильность выполнения ПО своих основных функций перед его передачей 
на более глубокое тестирование.

Понятие дымовое тестирование пошло из инженерной среды:
"При вводе в эксплуатацию нового оборудования ("железа") считалось, что тестирование прошло удачно, если из 
установки не пошел дым."
В области же программного обеспечения, дымовое тестирование рассматривается как короткий цикл тестов, 
выполняемый для подтверждения того, что после сборки кода (нового или исправленного) устанавливаемое приложение, 
стартует и выполняет основные функции.


============ САНИТАРНОЕ ТЕСТИРОВАНИЕ (Sanity testing) ============
Санитарное тестирование - это узконаправленное тестирование достаточное для доказательства того, что конкретная 
функция работает согласно заявленным в спецификации требованиям. Является подмножеством регрессионного тестирования. 
Используется для определения работоспособности определенной части приложения после изменений произведенных в ней 
или окружающей среде. Обычно выполняется вручную.

Санитарное тестирование используется каждый раз, когда мы получаем относительно стабильный билд ПО, чтобы 
определить работоспособность в деталях. Иными словами, здесь проходит валидация того, что важные части 
функциональности системы работают согласно требованиям на низком уровне.

----- Предназначение Sanity testing: -----
Определить, что измененные или добавленные функции работают нормально. 
Если санити-тест упал, QA-команда вовремя вернет код на доработку, и это экономия времени и денег для компании. 
Санитарное тестирование проводится после smoke-тестирования.

----- КЛЮЧЕВЫЕ ОСОБЕННОСТИ САНИТАРНОГО ТЕСТИРОВАНИЯ -----
1) По своей сути является процессом поверхностного тестирования с точной концентрацией на детализированной 
проверке избранной функциональности.
2) Является подмножеством регрессионного тестирования.
3) Проводится тогда, когда у QA нет запаса времени на выполнение детальной проверки всей сборки.
4) Процесс тестирования по обыкновению не документируется.
5) Представляет собой быстрое тестирование для наглядности убеждения в том, что внесенные изменения в 
конфигурацию ПО работают не так, как ожидалось.
6) Выполняется для быстрой проверки того, что незначительные погрешности в работе ПО были исправлены и не 
привели к глобальным конфигурационным ошибкам.

Примечание. 
Санитарным это тестирование в русскоязычной среде назвалось по совершенно непонятным причинам, но гуглится только так. 
На самом же деле дословно переводится как тестирование на вменяемость / разумность / работоспособность / согласованность  или, по версии ISTQB, - “Тест работоспособности”.

============ РЕГРЕССИОННОЕ ТЕСТИРОВАНИЕ (Regression testing) ============
Регрессионное тестирование (Regression testing) — это вид тестирования программного обеспечения, проводимый 
после обновления кода. Оно позволяет убедиться в том, что обновление не привело к появлению новых ошибок. 
Это связано с тем, что новый код может привнести новую логику, конфликтующую с существующим кодом, что нередко приводит к дефектам. 
Обычно QA-команды разрабатывают серию регрессионных тестов для важных функций, которые они будут заново 
выполнять при каждом изменении кода. Это помогает сэкономить время и повысить эффективность тестирования.

--- Что такое регрессионное тестирование? ---
Если программное обеспечение теряет функциональность из-за внедрения новых или измененных функций, говорят, 
что оно регрессировало до менее развитого состояния. Даже незначительные изменения в программном обеспечении или 
исходном коде могут привести к существенным ошибкам, таким как сбои, глюки, частичная или полная потеря функциональности.

Регрессионное тестирование используется для обнаружения этих ошибок и восстановления стабильности приложения. 
Процессы как функционального, так и нефункционального тестирования оценивают влияние новых функций на существующий код.

--- Типы регрессии по Канеру: ---
- Регрессия багов (Bug regression) - попытка доказать, что исправленная ошибка на самом деле не исправлена;
- Регрессия старых багов (Old bugs regression) - попытка доказать, что недавнее изменение кода или данных 
сломало исправление старых ошибок, т.е. старые баги стали снова воспроизводиться;
- Регрессия побочного эффекта (Side effect regression) - попытка доказать, что недавнее изменение кода или 
данных сломало другие части разрабатываемого приложения;


============ РЕ-ТЕСТ / Подтверждающее /повторное тестирование (confirmation testing, re-testing) ============

Подтверждающее тестирование (confirmation testing) - тестирование, при котором выполняются тестовые сценарии, 
которые были не пройдены при последнем запуске, с целью подтвердить успешность исправлений. (ISTQB)

Повторное тестирование - это тип тестирования, выполняемый в новой сборке по проваленному на старой сборке 
тест-кейсу с тем же окружением и данными, для проверки того, что этот дефект теперь устранен.

Перепроверяет и подтверждает факт того, что ранее заваленные тест-кейсы проходят после того, как дефекты исправлены.
Re-Test подтверждает факт того, что дефект исправлен.
Re-Test выполняется перед sanity-тестированием. 
Так же приоритет ре-теста выше регрессионных проверок, поэтому должен выполняться перед ними.


============ NEW FEATURE TESTING ============
new feature testing — это тестирование новых компонентов (нового функционала).



============ РУЧНОЕ ТЕСТИРОВАНИЕ (MANUAL TESTING) ============

Ручное тестирование — это тип тестирования программного обеспечения, при котором выполнение тестового сценария 
выполняется вручную человеком без использования автоматизированного инструмента. 
Это помогает в обеспечении выполнения как функциональных, так и нефункциональных требований.

Ручное (мануальное) тестирование — это тестирование без помощи каких-либо программ, автоматизирующих работу.
Например, чтобы протестировать работу формы авторизации, мы сами заходим на сайт и вручную заполняем поля «Имя» 
и «Пароль». То есть мы выступаем в роли обычного пользователя продукта.

Считается, что 100% автоматизация невозможна. Некоторые типы тестирования программного обеспечения, такие как 
исследовательское, юзабилити, удобство использования и т.д., могут выполняться только вручную. 
Поэтому ручное тестирование всегда необходимо, но наряду с его преимуществами есть и недостатки: это очень 
трудоемкий, ресурсоемкий процесс и подвержен человеческим ошибкам.

============ АВТОМАТИЗИРОВАННОЕ ТЕСТИРОВАНИЕ (AUTOMATION TESTING) ============

Автоматизированное тестирование – это метод тестирования ПО, при котором тестировщики для выполнения тест-кейсов 
используют автоматизированные программные инструменты. Автоматизация набора тестов помогает сэкономить время и 
усилия, необходимые для выполнения повторяющихся и ресурсоемких задач, которые трудно выполнять вручную.
Автоматизированное тестирование упрощает работу тестировщиков, оказывает положительное влияние на качество 
выпускаемого программного обеспечения, снижает затраты и ускоряет выход продукта на рынок.

Это тип тестирования, при котором выполнение тестового случая выполняется с использованием различных 
автоматизированных инструментов и тестовых скриптов. Его преимущество — как только создаются автоматизированные 
скрипты, это сэкономит много времени на выполнение тестов. Также это помогает в реализации непрерывной 
интеграции и непрерывного развертывания (CI/CD), при которых автоматизированные тестовые сценарии могут 
выполняться автоматически, как только новый код отправляется. Таким образом, выпуск продукта становится 
автоматическим и гораздо быстрее.

============ ПОЛУАВТОМАТИЗИРОВАННОЕ ТЕСТИРОВАНИЕ (SEMIAUTOMATED TESTING) ============
Полуавтоматизированное тестирование - это ручное тестирование с частичным использованием средств автоматизации 
(например автоматизация развертки окружения, автоматизация подготовки предусловий и т.д.).
При полуавтоматическом тестировании, ручной подход сочетается с автоматизированным. Зачастую бывает удобно 
создавать необходимые условия для проведения тестов автоматически а затем уже выставлять вердикт вручную. 
Данный тип тестирования применяется в случаях, когда полная автоматизация невозможна или невыгодна.


 =========== На основании чего происходит разработка тестовых сценариев? ===========
 



=========== Что такое Frontend / Backend ===========
Frontend — это клиентская часть продукта (интерфейс, с которым взаимодействует пользователь).
В случае с сайтом ее формирует и выводит на экран браузер, который работает с HTML, CSS и JavaScript.
Фронтенд — это пользовательский интерфейс на клиентской стороне веб-сайта или приложения. Это всё, что видит 
пользователь, когда открывает веб-страницу, и с чем он взаимодействует: кнопки, баннеры и анимация.

--- Компоненты фронтенд-разработки ---
Фронтенд сайта или веб-приложения можно разделить на три большие части:

-> HTML (HyperText Markup Language) — язык разметки документов, на котором создают структуру страницы: заголовки, абзацы, списки и так далее.
-> CSS (Cascading Style Sheets) — язык для описания и стилизации внешнего вида документа. 
Благодаря CSS-коду браузер понимает, как именно отображать элементы. Например, CSS задаёт цвета и параметры 
шрифтов, определяет, как будут располагаться разные блоки сайта. Ещё он позволяет воспроизводить документ в 
разных видах: для печати (обычной или шрифтом Брайля), вывода на экран или для чтения скринридером.
-> JavaScript — это язык, который оживляет веб-страницы. Его задача — реагировать на действия пользователя, 
обрабатывать клики мышки, перемещения курсора, нажатия клавиш. Ещё он посылает запросы на сервер и загружает 
данные без перезагрузки страницы, позволяет вводить сообщения и многое другое.


Backend — это внутренняя часть продукта, которая находится на сервере и скрыта от пользователей. 
Для ее разработки могут использоваться самые разные языки, например, Python, PHP, Go, JavaScript, Java, С#.

Бэкенд-разработка — это разработка бизнес-логики продукта (сайта или веб-приложения).
Бэкенд отвечает за взаимодействие пользователя с внутренними данными, которые потом отображает фронтенд. 
Попросту говоря, это то, что скрыто от глаз пользователя и происходит вне его браузера и компьютера.

----- Как работает бэкенд сайта -----

Когда вы вводите запрос на странице поисковика и жмёте клавишу Enter, вы переходите из области фронтенда бэкенд. 
Запрос отправляется на сервер Google или «Яндекса», на котором расположены сложные алгоритмы поиска, — там и 
происходит всё «волшебство». Как только на мониторе появилась информация, которую вы искали, — вы возвращаетесь 
в область фронтенда.
По большому счёту, сервер — это тот же компьютер, только удалённый и более мощный. Он хранит данные и отвечает 
на запросы пользователей.

----- Компоненты бэкенд-разработки -----
Бэкенд-разработчик применяет инструменты, которые доступны на его сервере. Он вправе выбрать любой из 
универсальных языков программирования — например, Ruby, PHP, Python или Java. Всё зависит от конкретного проекта 
и задачи заказчика.

Также для бэкенд-разработки используются системы управления базами данных:
- MySQL;
- PostgreSQL;
- SQLite;
- MongoDB.

Также используются инструменты загрузки (деплоя):
- CI/CD;
- Kubernetes (K8s);
- Docker.

Бэкенд — это не только написание кода, но и создание архитектуры приложения. Архитектура в разработке определяет 
структуру и порядок использования баз данных. Важно, чтобы база данных корректно взаимодействовала с кодом 
приложения и непрерывно доставлялась на сервер — за это отвечает бэкенд-разработчик.

----- Как взаимодействуют фронтенд и бэкенд -----
Взаимодействие фронтенда и бэкенда происходит по кругу:
- клиентская часть приложения (фронтенд) отправляет пользовательскую информацию на сервер (бэкенд);
- программа на сервере обрабатывает информацию;
- информация возвращается клиентской стороне в понятной для пользователя форме.



============ Тестирование безопасности (Security and Access Control testing) ============
Это тип тестирования ПО, который выявляет уязвимости, угрозы и риски. 
Целью тестов безопасности является выявление всех возможных лазеек и слабых мест в ПО, которые могут привести к 
потере информации, доходов, репутации компании, сотрудников или клиентов. 

Общая стратегия безопасности основывается на трех основных принципах:
-> Конфиденциальность - сокрытие определенных ресурсов или информации;
-> Целостность - ресурс может быть изменен только в соответствии с полномочиями пользователя;
-> Доступность - ресурсы должны быть доступны только авторизованному пользователю, внутреннему объекту или устройству;


-------- Виды уязвимостей в безопасности программного обеспечения --------
Обычно уязвимость позволяет атакующему «обмануть» приложение — выполнить непредусмотренные создателем действия 
или заставить приложение совершить действие, на которое у того не должно быть прав. Это делается путём внедрения 
каким-либо образом в программу данных или кода в такие места, что программа воспримет их как «свои». 
Некоторые уязвимости появляются из-за недостаточной проверки данных, вводимых пользователем, и позволяют 
вставить в интерпретируемый код произвольные команды (SQL-инъекция, XSS, SiXSS).

-> DDoS (Distributed Denial of Service) — атака, направленная на перегрузку сети или конкретного сервера большим 
количеством запросов. DDoS-атаки приводят к временной недоступности инфраструктуры.
-> SQL-инъекции — метод атаки, при котором злоумышленники внедряют SQL-код в запросы к базе данных для получения 
доступа к данным, содержащимся в этой БД.
-> Атаки Man-in-the-middle (MitM, «человек посередине») — атака, при которой злоумышленник получает доступ к 
каналу связи между легитимными сторонами (пользователями, приложениями, сетевыми устройствами и т.д.), что 
позволяет ему просматривать содержимое всех передаваемых ими сообщений, удалять и изменять их.
-> XSS (англ. Cross-Site Scripting — «межсайтовый скриптинг») — подтип атаки на веб-системы, заключающийся во 
внедрении в выдаваемую веб-системой страницу вредоносного кода (который будет выполнен на компьютере 
пользователя при открытии им этой страницы) и взаимодействии этого кода с веб-сервером злоумышленника. 
Является разновидностью атаки «Внедрение кода».


============== ТЕСТИРОВАНИЕ НА ОТКАЗ И ВОССТАНОВЛЕНИЕ (Failover and Recovery Testing) ===============
Тестирование на отказ и восстановление (Failover and Recovery Testing) проверяет тестируемый продукт с точки 
зрения способности противостоять и успешно восстанавливаться после возможных сбоев, возникших в связи с ошибками 
программного обеспечения, отказами оборудования или проблемами связи (например, отказ сети). 
Целью данного вида тестирования является проверка систем восстановления (или дублирующих основной функционал 
систем), которые, в случае возникновения сбоев, обеспечат сохранность и целостность данных тестируемого продукта.


============== ТЕСТИРОВАНИЕ ЭФФЕКТИВНОСТИ ИСПОЛЬЗОВАНИЯ РЕСУРСОВ  ===============
Тестирование эффективности использования ресурсов — это процесс проверки программного обеспечения на предмет 
того, как оно использует системные ресурсы, такие как процессор, память, дисковое пространство и сетевую пропускную способность. 
Цель этого вида тестирования заключается в определении возможных проблем с производительностью, которые могут 
возникнуть при использовании ПО, и устранении их для оптимизации работы системы.

Тестирование эффективности использования ресурсов важно по множеству причин. 
-> Во-первых, оно помогает обнаружить и устранить узкие места в производительности, которые могут привести к задержкам или сбоям в работе приложения. 
-> Во-вторых, оптимизация использования ресурсов может сэкономить средства на оборудовании и снизить затраты на энергию. 
-> В-третьих, улучшение производительности может увеличить удовлетворенность пользователей, что в свою очередь способствует росту и успеху продукта.

Примеры тестирования эффективности использования ресурсов
- Пример 1: Использование профилировщика памяти для выявления утечек памяти и определения неэффективного 
использования памяти в приложении.
- Пример 2: Тестирование сетевой производительности приложения для определения задержек и пропускной 
способности, а также выявления потенциальных проблем с масштабируемостью.
- Пример 3: Использование нагрузочного тестирования для определения времени отклика приложения при различных 
уровнях нагрузки и выявления возможных проблем с производительностью.
