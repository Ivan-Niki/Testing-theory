========= Что такое функциональное тестирование (Functional/Behavioral testing)? ===========

Функциональное тестирование представляет собой проверки ПО, по результатам которых устанавливается соответствие этого ПО исходным требованиям заказчика. 
Иными словами, с помощью проведения данных тестов устанавливается способность ПО в конкретных условиях решать пользовательские задачи.
Функциональные тесты основываются на функциях, выполняемых системой, и могут проводиться на всех уровнях 
тестирования (компонентном, интеграционном, системном, приемочном). 
Как правило, эти функции описываются в требованиях, функциональных спецификациях или в виде случаев использования системы (use cases).


========= Что такое нефункциональное тестирование (Non-Functional testing)? ===========

В отличии от функционального тестирования, целью которого является проверка соответствия реальных функций продукта с функциональными требованиями; 
целью нефункционального тестирования является проверка соответствия свойств приложения с его нефункциональными требованиями.
Нефункциональное тестирование – тестирование свойств, которые не относятся к функциональности системы. 

Данные свойства определяются нефункциональными требованиями, которые характеризуют продукт с таких сторон, как:
- Надежность (реакция системы на непредвиденные ситуации).
- Производительность (Работоспособность системы под разными нагрузками).
- Удобство (Исследование удобности работы с приложением с точки зрения пользователя).
- Масштабируемость (Требования к горизонтальному или вертикальному масштабированию приложения).
- Безопасность (Защищенность пользовательских данных).
- Портируемость (Переносимость приложения на различные платформы).

Данные свойства системы можно исследовать, используя следующие виды тестирования:
-> Тестирование установки (Installation testing) – проверка успешности установки приложения, его настройки и 
удаления. Снижает риски потери пользовательских данных, потери работоспособности приложения и пр.
-> Тестирование удобства использования (Usability testing) – характеризует систему с точки зрения удобства 
использования конечного пользователя.
-> Конфигурационное тестирование (или тестирование портируемости) – исследование работоспособности программной 
системы в условиях различных программных конфигураций.
-> Тестирование на отказ и восстановление (Failover and Recovery Testing) – исследование программной системы на 
предмет восстановления после ошибок, сбоев. Оценивание реакции защитных свойств приложения.


========= Какие виды тестирования относятся к функциональному тестированию? ===========


========= Какие виды тестирования относятся к нефункциональному тестированию? ===========
1) Тестирование графического интерфейса (GUI testing) — анализ соответствия графического пользовательского 
интерфейса программы спецификациям, макетам, прототипам, стандартам.

2) Тестирование удобства использования (Usability testing) — исследование, выполняемое с целью определения, удобна ли программа для ее предполагаемого применения и основанное на стандартах, лучших практиках и привлечении 
пользователей в качестве тестировщиков и суммировании и анализе полученных от них выводов.

3) Тестирование инсталляции (Installation testing) — тестирование, направленное на проверку процессов установки, 
удаления, восстановления, обновления, лицензирования.

4) Тестирование безопасности (Safety testing) — тестирование программного продукта с целью с целью определить его безопасность.
Безопасность (Safety) — способность программного продукта при использовании оговоренным образом оставаться в 
рамках приемлемого риска причинения вреда здоровью, бизнесу, программам, собственности или окружающей среде.

5) Тестирование защищенности (Security testing) — тестирование с целью оценить защищенность программного продукта.
Защищенность (Security) — Свойства программного продукта, отражающие его способность не допускать 
неавторизированный доступ, случайный или умышленный, к программам и данным.

6) Тестирование доступности (Accessibility testing) — тестирование, направленное на определение степени 
легкости, с которой пользователи с ограниченными способностями могут использовать систему или ее компоненты.

7) Тестирование производительности (Performance testing) — процесс тестирования с целью определить 
производительность программного продукта.

8) Нагрузочное тестирование (Load testing) — вид тестирования производительности, проводимый с целью оценить 
поведение компонента или системы под увеличивающейся нагрузкой (число одновременно работающих пользователей 
и/или число транзакций) для определения максимально допустимого уровня нагрузки для исследуемого компонента или системы.

9) Стрессовое тестирование (Stress testing) — Вид тестирования производительности, оценивающий систему или 
компонент на граничных значениях рабочих нагрузок или за их пределами, или же в состоянии ограниченных ресурсов, 
таких как память или доступ к серверу.

10) Тестирование интернационализации (Internationalization testing) — Анализ приложения и его интерфейса на 
способность быть переведённым.

11) Тестирование локализации (Localization testing) — Анализ приложения и его сопроводительной документации на 
корректность в конкретной переведённой среде.

12) Тестирование совместимости (Compatibility testing):

13) Тестирование кроссбраузерности (Cross browser testing) — Вид тестирования совместимости, направленный на 
анализ работы приложения в разных браузерах либо разных версиях одного браузера.

14) Тестирование кроссплатформенности (Cross platform testing) — Анализ работы одного и того же приложения на 
разных операционных системах\платформах.


========= Что такое Статическое/Динамическое тестированию? ===========
1) Статическое тестирование — не требует выполнения кода; это его суть. При этом оно может быть ручным или 
автоматизированным (например автоматические чекеры синтаксиса). 
Статические тесты начинаются на ранних этапах цикла разработки (SDLC). Такие тесты незаменимы при проверке MVP. 
Иногда даже не нужен компьютер — просто вручную проверяются самые базовые функции.
Техники статического тестирования включают, например, “тестирование” базовой документации приложения; 
поверхностную проверку кода; также документации по дизайну; спецификации функций; и требований по основным функциям.

2) Динамическое тестирование подразумевает выполнение кода при тестировании. 
Проверяется поведение приложения и функции, оценивается как задействованы память и процессор, и в целом производительность. 
QA-команда убеждается, что софт работает в соответствии с use-кейсами, ориентированными на бизнес-цели.
Динамическое тестирование имеет дело уже с полностью функциональным продуктом. QA-инженеры находят проблемы в 
логике и узкие места в инфраструктуре приложения, которые не были заметны на этапе написания проектной документации.
Динамическое тестирование проверяет, как работает код при выполнении — и сверяет результаты с ожидаемыми. 
Такое тестирование могут проводить на любом этапе жизненного цикла, и оно может быть как по типу черного ящика, так и белого ящика.
Динамическое тестирование находит сложные дефекты, невидимые при поверхностном анализе кода, во время статического тестирования.


========== Что такое Черный/Серый/Белый ящик тестирования(White/Black/Grey Box testing)? ==========
В методологии QA (Quality Assurance) есть классификация методов тестирования по прозрачности системы (программы, приложения). 
Она определяется тем, может ли тестировщик видеть код программного обеспечения и работать с ним.
Вот самое простое определение: 
- Тестирование белого ящика базируется на знаниях об устройстве системы. 
- Тестирование черного ящика базируется на знаниях требований к системе.

----- Метод "черного ящика" (Black box testing) -----
Тестирование методом Черного Ящика — это стратегия или метод тестирования, которая базируется только на 
тестировании по функциональной спецификации и требованиям, при этом не смотря во внутреннюю структуру кода 
и без доступа к базе данных.
Фактически мы знаем какой должен быть результат при определенном наборе данных, которые подаются на вход.
Нам достаточно знать, что должно быть при таком-то поведении пользователя и при таких-то наборах данных (зависит от специфики проекта).
Результат проверяем с юзер-интерфейса на уровне простого пользователя. 
На данный момент такая стратегия является наиболее часто применимой в IT компаниях.
Тестирование черного ящика — это, в первую очередь, проверка того, что продукт соответствует функциональным требованиям. 
Такое тестирование проводится на основе документации.

----- Метод "белого ящика" (White box testing) -----
Тестирование методом "белого ящика" ("стеклянного ящика") проверяет исходный код и ставит целью убедиться, что он работает правильно. 
Инженер, занимающийся тестированием методом "белого ящика", должен знать программирование на достаточном уровне. 
Часто такое тестирование проводят сами разработчики.

Два основных метода проведения тестирования методом "белого ящика":
--> 1) Statement coverage testing — покрытие операторов. Во время тестирования покрывают код так, чтобы каждый 
оператор выполнился хотя бы один раз.
--> 2) Decision/Branch coverage testing — покрытие решений. Код покрывается тестами так, чтобы во время 
тестирования выполнились все ветки всех условных операторов.

Наименьшая часть тестировщиков способны анализироваь чужой код и заниматься написанием тестов, не запуская 
программу или приложение, а только базируясь на коде.
Таких специалистов на рынке очень мало, и они скорее всего бывшие разработчики, ушедшие в тестирование или 
увлекающиеся программированием.

------ Метод "серого ящика" (Grey box testing) -----

Чуть меньшее количество тестировщиков тестируют стратегией "серого ящика", которая подразумевает частичный 
доступ, например к структуре баз данных или наборов параметров, которые принимают сервисы.
Тестировщик не влезает в код глубоко, но может посмотреть его реализацию, например, через инструмент разработчика (DevTools).
Тестирование методом «серого ящика» — это форма тестирования, сочетающая тестирование методом «белого ящика» и тестирование методом «черного ящика», использующая частичное понимание базового дизайна и способа реализации системы.
Такое сочетание означает, что тестировщик знает часть того, что происходит в фоновом режиме без полного знания 
кода, что позволяет лучше понять потенциальные причины проблем в программном обеспечении, когда они возникают.
Проведение тестирования методом «серого ящика» входит в обязанности тестировщиков, при этом команда обеспечения 
качества работает над проектом независимо от команды разработчиков.

--- Пример работы по методу "серого ящика" ----

1. Предоставлена информация о базе данных. Если программа использует для своей работы какую-либо БД, мы можем проанализировать типы полей, в которые записываются переменные программы. 
А потом проанализировать ограничения, которые накладывает база.

Например, если вводимая фамилия пользователя записывается в поле типа «строка» длиной 128 символов, мы должны:

- Попробовать найти фамилию длиннее, чем 128 символов. Если такие фамилии существуют, то человек с такой 
фамилией не сможет воспользоваться нашей системой — это довольно серьезный баг;
- Независимо от того, существуют или нет такие фамилии, попробовать ввести строку больше 128 символов. 
Программа не должна ломаться (должна выдавать внятное сообщение об ошибке).

2. Если программа интегрируется с другими внешними системами, помимо базы данных, можно также проанализировать ограничения таких систем. 
Например, если мы тестируем почтовый IMAP-клиент, следует убедиться, что он корректно обрабатывает длинные пути к папкам на сервере (чаще всего, ограничение на длину пути составляет 255 символов).

3. Пример тестирования методом "серого ящика": 
При тестировании таких элементов веб-сайта, как ссылки или "битые" ссылки, если тестировщик обнаружит какие-либо 
проблемы с этими ссылками, то он может сразу же внести изменения в HTML-код и проверить их в режиме реального времени.



=============== УРОВНИ ТЕСТИРОВАНИЯ (Testing Levels) ==============

Acceptance Testing
      ↑
System Testing
      ↑
Integration Testing
      ↑
Module/Unit/Component testing

---------- Что такое Компонентное (Component or Unit Testing) тестирование -----------

Компонент (component) - наименьший элемент программного обеспечения, который может быть протестирован отдельно.
Компонентное тестирование (component testing) - тестирование отдельных компонентов программного обеспечения.

Компонентное тестирование - тип тестирования ПО, при котором тестирование выполняется для каждого отдельного 
компонента отдельно, без интеграции с другими компонентами. Его также называют модульным тестированием (Module 
testing), если рассматривать его с точки зрения архитектуры. Как правило, любое программное обеспечение в целом 
состоит из нескольких компонентов. Тестирование на уровне компонентов (Component Level testing) имеет дело с 
тестированием этих компонентов индивидуально. Это один из самых частых типов тестирования черного ящика, который 
проводится командой QA.

Модульное тестирование (оно же юнит-тестирование) используется для тестирования какого-либо одного логически 
выделенного и изолированного элемента системы (отдельные методы класса или простая функция, subprograms, 
subroutines, классы или процедуры) в коде. 
Очевидно, что это тестирование методом БЕЛОГО ящика и чаще всего оно проводится самими разработчиками.
На уровне модульного тестирования проще всего обнаружить дефекты, связанные с алгоритмическими ошибками и 
ошибками кодирования алгоритмов, типа работы с условиями и счетчиками циклов, а также с использованием локальных 
переменных и ресурсов.


---------- Интеграционное тестирование (Integration testing) -----------

Интеграционное тестирование предназначено для проверки насколько хорошо два или более компонента ПО 
взаимодействуют друг с другом, а также взаимодействия с различными частями системы (операционной системой, 
оборудованием либо связи между различными системами).
Смысл интеграционного тестирования заключается в процессе тестирования интерфейсов между двумя компонентами или 
программными модулями для оценки того, как данные передаются между ними.
Интеграционное тестирование обычно проводится после модульного тестирования, которое включает в себя 
тестирование отдельных модулей и блоков. 
После того, как установлено, что каждый блок работает изолированно, интеграционное тестирование оценивает, как 
эти блоки работают при объединении.

Зачем нужно интеграционное тестирование:
— Разные разработчики используют разную логику при разработке модулей даже для одного и того же программного 
приложения. Интеграционное тестирование — это единственный способ убедиться, что отдельные модули работают 
вместе так, как должны.
— Когда данные переходят от одного модуля к другому, структура этих данных может измениться, а некоторые 
значения могут быть удалены. Это может вызвать значительные проблемы в работе модулей.
— Модули взаимодействуют со сторонними инструментами и API. Важно протестировать интеграцию, чтобы убедиться, 
что данные, принимаемые API или сторонним инструментом, корректны, а генерируемые ответы также соответствуют ожиданиям.
— Если разработчик внедряет изменения без модульного тестирования, интеграционное тестирование необходимо для 
оценки эффективности изменений.

Уровни интеграционного тестирования:
- Компонентный интеграционный уровень (Component Integration testing)
Проверяется взаимодействие между компонентами системы после проведения компонентного тестирования.
- Системный интеграционный уровень (System Integration Testing)
Проверяется взаимодействие между разными системами после проведения системного тестирования.

Подходы к интеграционному тестированию:
1) Подход большой взрыв ("Big Bang" Integration).
Все или практически все разработанные модули собираются вместе в виде законченной системы или ее основной части, 
и затем проводится интеграционное тестирование. Такой подход очень хорош для сохранения времени. Однако если 
тест кейсы и их результаты записаны не верно, то сам процесс интеграции сильно осложнится, что станет преградой 
для команды тестирования при достижении основной цели интеграционного тестирования.
